#!/usr/bin/env python3
"""
Dynamic Lifecycle Manager for Agent Neurogenesis
Handles creation, monitoring, and cleanup of dynamically generated agents.

This supports Phase 2 of biomimetic neurogenesis where we create and manage
template-based agents for new concepts.
"""

import json
import os
import time
import uuid
import subprocess
import requests
import shutil
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import threading
from pathlib import Path

# Import our template system
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from templates.agent_templates import get_template_manager, AgentTemplate

class AgentStatus(Enum):
    CREATING = "creating"
    STARTING = "starting"
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    STOPPED = "stopped"
    FAILED = "failed"
    REMOVING = "removing"

@dataclass
class DynamicAgent:
    """Represents a dynamically created agent"""
    agent_id: str
    agent_name: str
    concept: str
    template_id: str
    container_name: str
    port: int
    endpoint: str
    status: AgentStatus
    created_at: float
    last_health_check: float
    health_failures: int
    research_data: Dict[str, Any]
    capabilities: List[str]
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['status'] = self.status.value
        return result

class AgentCodeGenerator:
    """Generates Flask application code from agent templates"""
    
    def __init__(self):
        self.template_manager = get_template_manager()
    
    def generate_agent_code(self, agent_spec: Dict[str, Any]) -> str:
        """Generate complete Flask app code for an agent"""
        
        agent_name = agent_spec.get("agent_name", "Dynamic_Agent")
        concept = agent_spec.get("concept", "unknown")
        capabilities = agent_spec.get("primary_capabilities", [])
        knowledge = agent_spec.get("initial_knowledge", {})
        routes = agent_spec.get("flask_routes", [])
        
        # Generate the Flask application code
        app_code = '''#!/usr/bin/env python3
"""
{agent_name} - Dynamically Generated Agent
Concept: {concept}
Generated by: Myriad Neurogenesis System
Created: {timestamp}
"""

import json
import os
import requests
from flask import Flask, request, jsonify
from typing import Dict, Any, Optional, List

# Agent Configuration
AGENT_NAME = "{agent_name}"
AGENT_TYPE = "{agent_type}"
CONCEPT = "{concept}"
CAPABILITIES = {capabilities}

# Initial Knowledge Base (from research)
INITIAL_KNOWLEDGE = {knowledge}

# Agent-to-Agent Communication Configuration
GRAPHDB_MANAGER_URL = os.environ.get("GRAPHDB_MANAGER_URL", "http://graphdb_manager_ai:5008")

app = Flask(__name__)'''.format(
            agent_name=agent_name,
            concept=concept,
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S"),
            agent_type=agent_spec.get('agent_type', 'Unknown'),
            capabilities=json.dumps(capabilities),
            knowledge=json.dumps(knowledge, indent=2)
        )
        
        # Add the DynamicKnowledgeBase class to the generated code
        app_code += '''

class DynamicKnowledgeBase:
    """Dynamic knowledge management for the agent"""
    
    def __init__(self):
        self.knowledge = INITIAL_KNOWLEDGE.copy()
        self.confidence_scores = {}
        self.learning_enabled = True
    
    def get_knowledge(self, knowledge_type: str = "primary") -> str:
        """Retrieve knowledge of a specific type"""
        
        if knowledge_type == "definition":
            return self.knowledge.get("primary_definition", f"A {{CONCEPT}} is a concept requiring further research.")
        
        elif knowledge_type == "applications":
            apps = self.knowledge.get("applications", [])
            if apps:
                return f"{{CONCEPT}} has applications in: " + ", ".join(apps)
            return f"{{CONCEPT}} applications are being researched."
        
        elif knowledge_type == "relationships":
            related = self.knowledge.get("related_concepts", [])
            if related:
                return f"{{CONCEPT}} is related to: " + ", ".join(related)
            return f"{{CONCEPT}} relationships are being mapped."
        
        elif knowledge_type == "research_summary":
            return self.knowledge.get("primary_definition", f"Research on {{CONCEPT}} is ongoing.")
        
        else:
            # Default knowledge response
            confidence = self.knowledge.get("confidence_score", 0.0)
            if confidence > 0.5:
                return self.knowledge.get("primary_definition", f"Information about {{CONCEPT}} is available.")
            else:
                return f"I am learning about {{CONCEPT}}. My current understanding is limited but growing."
    
    def update_knowledge(self, knowledge_type: str, content: str, confidence: float = 0.5):
        """Update knowledge base with new information"""
        if self.learning_enabled:
            if "learned_knowledge" not in self.knowledge:
                self.knowledge["learned_knowledge"] = {{}}
            
            self.knowledge["learned_knowledge"][knowledge_type] = content
            self.confidence_scores[knowledge_type] = confidence
            
            # Update overall confidence
            if self.confidence_scores:
                avg_confidence = sum(self.confidence_scores.values()) / len(self.confidence_scores)
                self.knowledge["confidence_score"] = avg_confidence

# Initialize knowledge base
knowledge_base = DynamicKnowledgeBase()

def discover_peer_agents(concept: str) -> List[Dict[str, Any]]:
    """Discover other agents that handle a specific concept"""
    try:
        payload = {{
            "start_node_label": "Concept",
            "start_node_properties": {{"name": concept.lower()}},
            "relationship_type": "HANDLES_CONCEPT", 
            "relationship_direction": "in",
            "target_node_label": "Agent"
        }}
        
        response = requests.post(f"{{GRAPHDB_MANAGER_URL}}/find_connected_nodes", 
                               json=payload, timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            return data.get("nodes", [])
        return []
    except Exception as e:
        print(f"Error discovering peers: {{e}}")
        return []

def request_peer_collaboration(peer_endpoint: str, collaboration_request: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Send collaboration request to a peer agent"""
    try:
        response = requests.post(f"{{peer_endpoint}}/collaborate", 
                               json=collaboration_request, timeout=10)
        if response.status_code == 200:
            return response.json()
        return None
    except Exception as e:
        print(f"Collaboration error: {{e}}")
        return None

'''

        # Add health endpoint
        if "/health" in routes:
            app_code += '''
@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        "status": "healthy",
        "agent": AGENT_NAME,
        "concept": CONCEPT,
        "capabilities": CAPABILITIES,
        "knowledge_confidence": knowledge_base.knowledge.get("confidence_score", 0.0),
        "uptime": time.time()
    }), 200
'''

        # Add collaboration endpoint
        if "/collaborate" in routes:
            app_code += '''
@app.route('/collaborate', methods=['POST'])
def collaborate():
    """Handle collaboration requests from other agents"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"status": "error", "message": "No data provided"}), 400
        
        collaboration_type = data.get("collaboration_type")
        target_concept = data.get("target_concept", "").lower()
        
        # Check if this request is for our concept
        if target_concept != CONCEPT.lower():
            return jsonify({
                "status": "no_expertise",
                "message": f"I specialize in '{CONCEPT}', not '{target_concept}'"
            }), 200
        
        if collaboration_type == "knowledge_request":
            return handle_knowledge_request(data)
        elif collaboration_type == "context_sharing":
            return handle_context_sharing(data)
        elif collaboration_type == "concept_research":
            return handle_concept_research(data)
        else:
            return jsonify({
                "status": "unsupported",
                "message": f"Collaboration type '{collaboration_type}' not supported"
            }), 400
            
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500

def handle_knowledge_request(data: Dict[str, Any]) -> tuple:
    """Handle knowledge request collaboration"""
    request_details = data.get("specific_request", {})
    knowledge_type = request_details.get("knowledge_type", "definition")
    
    knowledge = knowledge_base.get_knowledge(knowledge_type)
    confidence = knowledge_base.knowledge.get("confidence_score", 0.5)
    
    response_data = {
        "primary_knowledge": knowledge,
        "knowledge_type": knowledge_type,
        "confidence": confidence,
        "source": AGENT_NAME,
        "concept": CONCEPT
    }
    
    return jsonify({
        "status": "success",
        "data": response_data,
        "collaboration_metadata": {
            "collaboration_type": "knowledge_sharing",
            "response_to": data.get("source_agent", {}).get("name", "Unknown"),
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ")
        }
    }), 200

def handle_context_sharing(data: Dict[str, Any]) -> tuple:
    """Handle context sharing collaboration"""
    context_data = {
        "concept": CONCEPT,
        "key_attributes": knowledge_base.knowledge.get("applications", []),
        "related_concepts": knowledge_base.knowledge.get("related_concepts", []),
        "confidence_level": knowledge_base.knowledge.get("confidence_score", 0.5),
        "specialization": AGENT_TYPE
    }
    
    return jsonify({
        "status": "success", 
        "data": context_data,
        "collaboration_metadata": {
            "collaboration_type": "context_sharing",
            "response_to": data.get("source_agent", {}).get("name", "Unknown"),
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ")
        }
    }), 200

def handle_concept_research(data: Dict[str, Any]) -> tuple:
    """Handle concept research requests (for neurogenesis)"""
    concept = data.get("target_concept", "").lower()
    
    if concept == CONCEPT.lower():
        # This is our area of expertise
        research_summary = knowledge_base.get_knowledge("research_summary")
        confidence = knowledge_base.knowledge.get("confidence_score", 0.5)
        
        response_data = {
            "primary_knowledge": research_summary,
            "research_confidence": confidence,
            "research_depth": "specialized",
            "expertise_level": "high",
            "additional_context": knowledge_base.knowledge
        }
        
        return jsonify({
            "status": "success",
            "data": response_data
        }), 200
    else:
        return jsonify({
            "status": "no_expertise",
            "message": f"I specialize in '{CONCEPT}', not '{concept}'"
        }), 200
'''

        # Add query endpoint if specified
        if "/query" in routes:
            app_code += '''
@app.route('/query', methods=['POST'])
def query():
    """Direct query endpoint for the agent's knowledge"""
    try:
        data = request.get_json()
        query_type = data.get("query_type", "definition")
        
        knowledge = knowledge_base.get_knowledge(query_type)
        confidence = knowledge_base.knowledge.get("confidence_score", 0.5)
        
        return jsonify({
            "status": "success",
            "concept": CONCEPT,
            "query_type": query_type,
            "knowledge": knowledge,
            "confidence": confidence,
            "agent": AGENT_NAME
        }), 200
        
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500
'''

        # Add learning endpoint if specified
        if "/update_knowledge" in routes:
            app_code += '''
@app.route('/update_knowledge', methods=['POST'])
def update_knowledge():
    """Update the agent's knowledge base"""
    try:
        data = request.get_json()
        knowledge_type = data.get("knowledge_type")
        content = data.get("content")
        confidence = data.get("confidence", 0.5)
        
        if not knowledge_type or not content:
            return jsonify({"status": "error", "message": "Missing required fields"}), 400
        
        knowledge_base.update_knowledge(knowledge_type, content, confidence)
        
        return jsonify({
            "status": "success",
            "message": f"Updated {knowledge_type} knowledge",
            "new_confidence": knowledge_base.knowledge.get("confidence_score", 0.5)
        }), 200
        
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500
'''

        # Add the main application runner
        app_code += '''
if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    print(f"ü§ñ {AGENT_NAME} starting on port {port}")
    print(f"üìö Specializing in: {CONCEPT}")
    print(f"üß† Capabilities: {', '.join(CAPABILITIES)}")
    print(f"‚ú® Knowledge confidence: {knowledge_base.knowledge.get('confidence_score', 0.0):.2f}")
    
    app.run(host='0.0.0.0', port=port, debug=False)
'''

        return app_code
    
    def generate_dockerfile(self, agent_spec: Dict[str, Any]) -> str:
        """Generate Dockerfile for the agent"""
        
        dependencies = agent_spec.get("dependencies", ["flask", "requests"])
        base_image = agent_spec.get("docker_base_image", "python:3.11-slim")
        startup_script = agent_spec.get("startup_script", "app.py")
        
        dockerfile = f'''FROM {base_image}

WORKDIR /app

# Install Python dependencies
RUN pip install {' '.join(dependencies)}

# Copy application code
COPY {startup_script} .

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:5000/health || exit 1

# Run the application
CMD ["python", "{startup_script}"]
'''
        return dockerfile

class DynamicLifecycleManager:
    """Manages the lifecycle of dynamically created agents"""
    
    def __init__(self):
        self.agents: Dict[str, DynamicAgent] = {}
        self.template_manager = get_template_manager()
        self.code_generator = AgentCodeGenerator()
        self.agent_dir = Path("dynamic_agents")
        self.agent_dir.mkdir(exist_ok=True)
        self.port_allocator = PortAllocator(7000, 9999)
        self.monitor_thread = None
        self.monitoring = False
        
    def create_agent(self, concept: str, intent: str, research_data: Dict[str, Any]) -> Optional[DynamicAgent]:
        """Create a new dynamic agent for a concept"""
        
        print(f"üß¨ Creating dynamic agent for concept '{concept}'...")
        
        try:
            # Step 1: Select and customize template
            template_id = self.template_manager.suggest_template(concept, intent, research_data)
            agent_spec = self.template_manager.customize_template(template_id, concept, research_data)
            
            # Step 2: Generate unique identifiers
            agent_id = str(uuid.uuid4())[:8]
            agent_name = agent_spec["agent_name"]
            container_name = f"myriad_{concept.lower().replace(' ', '_')}_{agent_id}"
            
            # Step 3: Allocate port
            port = self.port_allocator.allocate_port()
            if not port:
                print(f"‚ùå No available ports for agent {agent_name}")
                return None
                
            # Step 4: Create agent directory
            agent_path = self.agent_dir / container_name
            agent_path.mkdir(exist_ok=True)
            
            # Step 5: Generate code files
            app_code = self.code_generator.generate_agent_code(agent_spec)
            dockerfile = self.code_generator.generate_dockerfile(agent_spec)
            
            # Step 6: Write files
            (agent_path / "app.py").write_text(app_code)
            (agent_path / "Dockerfile").write_text(dockerfile)
            (agent_path / "agent_spec.json").write_text(json.dumps(agent_spec, indent=2))
            
            # Step 7: Create agent record
            agent = DynamicAgent(
                agent_id=agent_id,
                agent_name=agent_name,
                concept=concept,
                template_id=template_id,
                container_name=container_name,
                port=port,
                endpoint=f"http://localhost:{port}",
                status=AgentStatus.CREATING,
                created_at=time.time(),
                last_health_check=0,
                health_failures=0,
                research_data=research_data,
                capabilities=agent_spec.get("primary_capabilities", [])
            )
            
            # Step 8: Build and start the agent
            if self._build_and_start_agent(agent, agent_path):
                self.agents[agent_id] = agent
                print(f"‚úÖ Successfully created agent {agent_name} (ID: {agent_id})")
                return agent
            else:
                print(f"‚ùå Failed to build/start agent {agent_name}")
                self.port_allocator.release_port(port)
                shutil.rmtree(agent_path, ignore_errors=True)
                return None
                
        except Exception as e:
            print(f"‚ùå Error creating agent for '{concept}': {e}")
            return None
    
    def _build_and_start_agent(self, agent: DynamicAgent, agent_path: Path) -> bool:
        """Build and start the Docker container for an agent"""
        
        try:
            print(f"  üî® Building Docker image for {agent.agent_name}...")
            
            # Build Docker image
            build_result = subprocess.run([
                "docker", "build", "-t", agent.container_name, str(agent_path)
            ], capture_output=True, text=True, timeout=300)
            
            if build_result.returncode != 0:
                print(f"  ‚ùå Docker build failed: {build_result.stderr}")
                return False
            
            print(f"  üöÄ Starting container {agent.container_name}...")
            
            # Start container
            run_result = subprocess.run([
                "docker", "run", "-d", 
                "--name", agent.container_name,
                "-p", f"{agent.port}:5000",
                "-e", f"PORT=5000",
                agent.container_name
            ], capture_output=True, text=True, timeout=60)
            
            if run_result.returncode != 0:
                print(f"  ‚ùå Docker run failed: {run_result.stderr}")
                return False
            
            agent.status = AgentStatus.STARTING
            
            # Wait for container to be ready
            return self._wait_for_agent_ready(agent)
            
        except Exception as e:
            print(f"  ‚ùå Build/start error: {e}")
            return False
    
    def _wait_for_agent_ready(self, agent: DynamicAgent, timeout: int = 60) -> bool:
        """Wait for agent to be ready and healthy"""
        
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                response = requests.get(f"{agent.endpoint}/health", timeout=5)
                if response.status_code == 200:
                    agent.status = AgentStatus.HEALTHY
                    agent.last_health_check = time.time()
                    print(f"  ‚úÖ Agent {agent.agent_name} is healthy!")
                    return True
            except:
                pass
            
            time.sleep(2)
        
        agent.status = AgentStatus.FAILED
        print(f"  ‚ùå Agent {agent.agent_name} failed to become healthy")
        return False
    
    def stop_agent(self, agent_id: str) -> bool:
        """Stop and remove a dynamic agent"""
        
        agent = self.agents.get(agent_id)
        if not agent:
            return False
        
        print(f"üõë Stopping agent {agent.agent_name}...")
        
        try:
            # Stop container
            subprocess.run(["docker", "stop", agent.container_name], 
                         capture_output=True, timeout=30)
            
            # Remove container  
            subprocess.run(["docker", "rm", agent.container_name],
                         capture_output=True, timeout=30)
            
            # Release port
            self.port_allocator.release_port(agent.port)
            
            # Remove from registry
            del self.agents[agent_id]
            
            print(f"‚úÖ Stopped agent {agent.agent_name}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error stopping agent: {e}")
            return False
    
    def list_agents(self) -> List[Dict[str, Any]]:
        """List all dynamic agents"""
        return [agent.to_dict() for agent in self.agents.values()]
    
    def get_agent(self, agent_id: str) -> Optional[DynamicAgent]:
        """Get a specific agent"""
        return self.agents.get(agent_id)

class PortAllocator:
    """Manages port allocation for dynamic agents"""
    
    def __init__(self, start_port: int, end_port: int):
        self.start_port = start_port
        self.end_port = end_port
        self.allocated_ports = set()
    
    def allocate_port(self) -> Optional[int]:
        """Allocate an available port"""
        for port in range(self.start_port, self.end_port + 1):
            if port not in self.allocated_ports:
                self.allocated_ports.add(port)
                return port
        return None
    
    def release_port(self, port: int):
        """Release a port back to the pool"""
        self.allocated_ports.discard(port)

# Global lifecycle manager instance
lifecycle_manager = DynamicLifecycleManager()

def get_lifecycle_manager() -> DynamicLifecycleManager:
    """Get the global lifecycle manager instance"""
    return lifecycle_manager

if __name__ == "__main__":
    # Demo the lifecycle manager
    print("üß¨ Dynamic Lifecycle Manager Demo")
    print("=" * 40)
    
    manager = get_lifecycle_manager()
    
    # Example: Create an agent for "LED" concept  
    research_data = {
        "concept": "LED",
        "confidence_score": 0.8,
        "primary_definition": "Based on research: LED appears to be a type of lighting technology. Like traditional incandescent lightbulbs, it likely converts electrical energy into light, but may use different mechanisms for illumination.",
        "applications": ["lighting", "displays", "indicators"],
        "related_concepts": ["light", "semiconductor", "electricity"],
        "research_sources": ["Lightbulb_Definition_AI"]
    }
    
    print("Creating dynamic agent for 'LED'...")
    agent = manager.create_agent("LED", "define", research_data)
    
    if agent:
        print(f"‚úÖ Agent created: {agent.agent_name}")
        print(f"   Port: {agent.port}")
        print(f"   Status: {agent.status.value}")
        print(f"   Endpoint: {agent.endpoint}")
    else:
        print("‚ùå Failed to create agent")
        
    print(f"\nActive agents: {len(manager.list_agents())}")
